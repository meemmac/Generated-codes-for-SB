{
"title": "Li Chao Segment Tree",
"subtitle": "Segment tree variant to maintain lines for min/max queries efficiently",
"time_complexity": "O(log N) per update/query",
"space_complexity": "O(N log N)",
"category": "Data Structure / DP Optimization",
"code": [
    "class Line:",
    "    def __init__(self, m=0, b=float('inf')):",
    "        self.m = m",
    "        self.b = b",
    "    def value(self, x):",
    "        return self.m * x + self.b",
    "class LiChaoTree:",
    "    def __init__(self, xs):",
    "        self.xs = sorted(list(set(xs)))",
    "        self.size = len(self.xs)",
    "        self.tree = [Line() for _ in range(4*self.size)]",
    "    def update(self, node, l, r, new_line):",
    "        mid = (l+r)//2",
    "        left_x = self.xs[l]",
    "        mid_x = self.xs[mid]",
    "        right_x = self.xs[r]",
    "        curr = self.tree[node]",
    "        if curr.value(mid_x) > new_line.value(mid_x):",
    "            self.tree[node], new_line = new_line, curr",
    "        if l == r:",
    "            return",
    "        if curr.value(left_x) > new_line.value(left_x):",
    "            self.update(2*node, l, mid, new_line)",
    "        elif curr.value(right_x) > new_line.value(right_x):",
    "            self.update(2*node+1, mid+1, r, new_line)",
    "    def query(self, node, l, r, x_idx):",
    "        if l == r:",
    "            return self.tree[node].value(self.xs[x_idx])",
    "        mid = (l+r)//2",
    "        res = self.tree[node].value(self.xs[x_idx])",
    "        if x_idx <= mid:",
    "            res = min(res, self.query(2*node, l, mid, x_idx))",
    "        else:",
    "            res = min(res, self.query(2*node+1, mid+1, r, x_idx))",
    "        return res"
],
"additional_information": "Li Chao Tree allows insertion of lines and fast min/max queries. Useful for dynamic DP optimization."
}
