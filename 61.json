{
"title": "Johnson's Algorithm",
"subtitle": "Compute all-pairs shortest paths in a sparse graph",
"time_complexity": "O(V^2 log V + V*E)",
"space_complexity": "O(V^2 + E)",
"category": "Graph / Shortest Paths",
"code": [
    "import heapq",
    "",
    "def johnson(graph):",
    "    n = len(graph)",
    "    new_graph = [row[:] for row in graph] + [[0]*n]",
    "    # Bellman-Ford on new vertex to reweight edges",
    "    h = [0] * (n + 1)",
    "    for _ in range(n):",
    "        for u in range(n):",
    "            for v, w in enumerate(graph[u]):",
    "                if w != float('inf') and h[u] + w < h[v]:",
    "                    h[v] = h[u] + w",
    "    # Reweight edges",
    "    reweighted = [[graph[u][v] + h[u] - h[v] if graph[u][v] != float('inf') else float('inf') for v in range(n)] for u in range(n)]",
    "    # Dijkstra for each vertex",
    "    all_dist = []",
    "    for src in range(n):",
    "        dist = [float('inf')] * n",
    "        dist[src] = 0",
    "        pq = [(0, src)]",
    "        while pq:",
    "            d, u = heapq.heappop(pq)",
    "            if d > dist[u]: continue",
    "            for v, w in enumerate(reweighted[u]):",
    "                if w != float('inf') and dist[u] + w < dist[v]:",
    "                    dist[v] = dist[u] + w",
    "                    heapq.heappush(pq, (dist[v], v))",
    "        # Recover original weights",
    "        dist = [dist[v] - h[src] + h[v] for v in range(n)]",
    "        all_dist.append(dist)",
    "    return all_dist"
],
"additional_information": "Johnson's algorithm efficiently computes all-pairs shortest paths in sparse graphs using a combination of Bellman-Ford (for reweighting) and Dijkstra's algorithm (for shortest paths from each vertex)."
}
