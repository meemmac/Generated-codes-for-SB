{
"title": "A* Search Algorithm",
"subtitle": "Find the shortest path using a heuristic to guide the search",
"time_complexity": "O(E)",
"space_complexity": "O(V)",
"category": "Graph / Search",
"code": [
    "import heapq",
    "",
    "def a_star(graph, start, goal, h):",
    "    open_set = [(h[start], 0, start)]",
    "    came_from = {}",
    "    g_score = {node: float('inf') for node in graph}",
    "    g_score[start] = 0",
    "",
    "    while open_set:",
    "        _, current_g, current = heapq.heappop(open_set)",
    "        if current == goal:",
    "            path = []",
    "            while current in came_from:",
    "                path.append(current)",
    "                current = came_from[current]",
    "            path.append(start)",
    "            return path[::-1]",
    "",
    "        for neighbor, weight in graph[current]:",
    "            tentative_g = current_g + weight",
    "            if tentative_g < g_score[neighbor]:",
    "                g_score[neighbor] = tentative_g",
    "                came_from[neighbor] = current",
    "                heapq.heappush(open_set, (tentative_g + h[neighbor], tentative_g, neighbor))",
    "",
    "    return None"
],
"additional_information": "A* uses a heuristic to prioritize nodes likely to lead to the goal, combining the benefits of Dijkstra and greedy best-first search."
}
