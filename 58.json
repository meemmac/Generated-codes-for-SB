{
"title": "Edmonds-Karp Algorithm",
"subtitle": "Compute the maximum flow in a flow network using BFS-based Ford-Fulkerson",
"time_complexity": "O(V * E^2)",
"space_complexity": "O(V + E)",
"category": "Graph / Maximum Flow",
"code": [
    "from collections import deque",
    "",
    "def bfs(residual_graph, source, sink, parent):",
    "    visited = [False] * len(residual_graph)",
    "    queue = deque([source])",
    "    visited[source] = True",
    "    while queue:",
    "        u = queue.popleft()",
    "        for v, capacity in enumerate(residual_graph[u]):",
    "            if not visited[v] and capacity > 0:",
    "                queue.append(v)",
    "                visited[v] = True",
    "                parent[v] = u",
    "                if v == sink:",
    "                    return True",
    "    return False",
    "",
    "def edmonds_karp(graph, source, sink):",
    "    residual_graph = [row[:] for row in graph]",
    "    parent = [-1] * len(graph)",
    "    max_flow = 0",
    "    while bfs(residual_graph, source, sink, parent):",
    "        path_flow = float('inf')",
    "        s = sink",
    "        while s != source:",
    "            path_flow = min(path_flow, residual_graph[parent[s]][s])",
    "            s = parent[s]",
    "        v = sink",
    "        while v != source:",
    "            u = parent[v]",
    "            residual_graph[u][v] -= path_flow",
    "            residual_graph[v][u] += path_flow",
    "            v = parent[v]",
    "        max_flow += path_flow",
    "    return max_flow"
],
"additional_information": "Edmonds-Karp is a BFS-based implementation of the Ford-Fulkerson method for finding the maximum flow. It ensures polynomial time complexity by always selecting the shortest augmenting path in terms of edge count."
}
