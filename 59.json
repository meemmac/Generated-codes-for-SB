{
"title": "Dinic's Algorithm",
"subtitle": "Compute maximum flow using level graphs and blocking flows",
"time_complexity": "O(V^2 * E) general, O(sqrt(V) * E) for unit networks",
"space_complexity": "O(V + E)",
"category": "Graph / Maximum Flow",
"code": [
    "from collections import deque",
    "",
    "class Edge:",
    "    def __init__(self, to, rev, cap):",
    "        self.to = to",
    "        self.rev = rev",
    "        self.cap = cap",
    "",
    "def bfs(level, graph, s, t):",
    "    queue = deque([s])",
    "    level[s] = 0",
    "    while queue:",
    "        v = queue.popleft()",
    "        for e in graph[v]:",
    "            if e.cap > 0 and level[e.to] < 0:",
    "                level[e.to] = level[v] + 1",
    "                queue.append(e.to)",
    "    return level[t] != -1",
    "",
    "def dfs(level, iter, graph, v, t, upTo):",
    "    if v == t:",
    "        return upTo",
    "    for i in range(iter[v], len(graph[v])):",
    "        e = graph[v][i]",
    "        if e.cap > 0 and level[v] < level[e.to]:",
    "            d = dfs(level, iter, graph, e.to, t, min(upTo, e.cap))",
    "            if d > 0:",
    "                e.cap -= d",
    "                graph[e.to][e.rev].cap += d",
    "                return d",
    "        iter[v] += 1",
    "    return 0",
    "",
    "def dinic(graph, s, t):",
    "    flow = 0",
    "    level = [-1] * len(graph)",
    "    while bfs(level, graph, s, t):",
    "        iter = [0] * len(graph)",
    "        f = dfs(level, iter, graph, s, t, float('inf'))",
    "        while f > 0:",
    "            flow += f",
    "            f = dfs(level, iter, graph, s, t, float('inf'))",
    "        level = [-1] * len(graph)",
    "    return flow"
],
"additional_information": "Dinic's algorithm improves on Edmonds-Karp by using level graphs and DFS blocking flows, resulting in faster performance for dense graphs and unit capacity networks."
}
