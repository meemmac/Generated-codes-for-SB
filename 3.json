{
"title": "Merge Sort",
"subtitle": "A stable divide-and-conquer sorting algorithm",
"time_complexity": "O(N log N)",
"space_complexity": "O(N)",
"category": "Sorting",
"code": [
    "def merge_sort(arr):",
    "    if len(arr) <= 1:",
    "        return arr",
    "",
    "    mid = len(arr) // 2",
    "    left = merge_sort(arr[:mid])",
    "    right = merge_sort(arr[mid:])",
    "",
    "    return merge(left, right)",
    "",
    "def merge(left, right):",
    "    result = []",
    "    i = j = 0",
    "",
    "    while i < len(left) and j < len(right):",
    "        if left[i] <= right[j]:",
    "            result.append(left[i])",
    "            i += 1",
    "        else:",
    "            result.append(right[j])",
    "            j += 1",
    "",
    "    result.extend(left[i:])",
    "    result.extend(right[j:])",
    "    return result"
],
"additional_information": "Merge sort is stable, works well for linked lists, and its performance is consistent regardless of input distribution."
}
