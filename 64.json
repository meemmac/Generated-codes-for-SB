{
"title": "Boykov-Kolmogorov Algorithm",
"subtitle": "Compute min-cut / max-flow in computer vision problems",
"time_complexity": "O(V^2 * E) worst case, often much faster in practice",
"space_complexity": "O(V + E)",
"category": "Graph / Max Flow",
"code": [
    "from collections import deque",
    "",
    "class Edge:",
    "    def __init__(self, to, rev, cap):",
    "        self.to = to",
    "        self.rev = rev",
    "        self.cap = cap",
    "",
    "class BKGraph:",
    "    def __init__(self, n):",
    "        self.n = n",
    "        self.graph = [[] for _ in range(n)]",
    "",
    "    def add_edge(self, u, v, cap):",
    "        self.graph[u].append(Edge(v, len(self.graph[v]), cap))",
    "        self.graph[v].append(Edge(u, len(self.graph[u]) - 1, 0))  # reverse edge",
    "",
    "def boykov_kolmogorov_max_flow(bk_graph, source, sink):",
    "    n = bk_graph.n",
    "    graph = bk_graph.graph",
    "    # Initialize active nodes and trees",
    "    parent = [None] * n",
    "    tree = [None] * n  # 'S' for source tree, 'T' for sink tree, None for free",
    "    active = deque()",
    "",
    "    # Initialize source and sink trees",
    "    tree[source] = 'S'",
    "    tree[sink] = 'T'",
    "    active.append(source)",
    "    active.append(sink)",
    "",
    "    max_flow = 0",
    "",
    "    def augment(path):",
    "        # Find minimum residual capacity along path",
    "        flow = float('inf')",
    "        for u, e in path:",
    "            flow = min(flow, e.cap)",
    "        # Update residual capacities",
    "        for u, e in path:",
    "            e.cap -= flow",
    "            graph[e.to][e.rev].cap += flow",
    "        return flow",
    "",
    "    while active:",
    "        u = active.popleft()",
    "        for e in graph[u]:",
    "            if e.cap > 0:",
    "                v = e.to",
    "                # If v is free, attach to the same tree",
    "                if tree[v] is None:",
    "                    tree[v] = tree[u]",
    "                    parent[v] = (u, e)",
    "                    active.append(v)",
    "                # If v belongs to opposite tree, augmenting path found",
    "                elif tree[v] != tree[u]:",
    "                    # Reconstruct path from source to sink",
    "                    path = []",
    "                    x = u",
    "                    while x != source and tree[x] == 'S':",
    "                        path.append(parent[x])",
    "                        x = parent[x][0]",
    "                    path = path[::-1]",
    "                    path.append((u, e))",
    "                    y = v",
    "                    while y != sink and tree[y] == 'T':",
    "                        path.append((parent[y][0], graph[parent[y][0]][parent[y][1].rev]))",
    "                        y = parent[y][0]",
    "                    max_flow += augment(path)",
    "                    # Reset active nodes for next iteration",
    "                    active = deque([i for i in range(n) if tree[i] is not None])",
    "                    break",
    "",
    "    return max_flow"
],
"additional_information": "The Boykov-Kolmogorov algorithm is designed for fast max-flow computation in computer vision applications like image segmentation. It maintains two trees growing from source and sink and repeatedly finds augmenting paths when the trees meet, adjusting residual capacities and adopting orphan nodes. It's highly efficient in practice despite a higher worst-case complexity."
}
