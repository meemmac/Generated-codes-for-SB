{
"title": "Ford-Fulkerson Algorithm",
"subtitle": "Compute the maximum flow in a flow network",
"time_complexity": "O(E * max_flow)",
"space_complexity": "O(V + E)",
"category": "Graph Theory / Network Flow",
"code": [
    "from collections import deque",
    "def bfs(residual_graph, source, sink, parent):",
    "    visited = [False] * len(residual_graph)",
    "    queue = deque([source])",
    "    visited[source] = True",
    "    while queue:",
    "        u = queue.popleft()",
    "        for v, capacity in enumerate(residual_graph[u]):",
    "            if not visited[v] and capacity > 0:",
    "                queue.append(v)",
    "                visited[v] = True",
    "                parent[v] = u",
    "    return visited[sink]",
    "",
    "def ford_fulkerson(graph, source, sink):",
    "    residual_graph = [row[:] for row in graph]",
    "    parent = [-1] * len(graph)",
    "    max_flow = 0",
    "    while bfs(residual_graph, source, sink, parent):",
    "        path_flow = float('inf')",
    "        s = sink",
    "        while s != source:",
    "            path_flow = min(path_flow, residual_graph[parent[s]][s])",
    "            s = parent[s]",
    "        max_flow += path_flow",
    "        v = sink",
    "        while v != source:",
    "            u = parent[v]",
    "            residual_graph[u][v] -= path_flow",
    "            residual_graph[v][u] += path_flow",
    "            v = parent[v]",
    "    return max_flow"
],
"additional_information": "Ford-Fulkerson computes the maximum flow in a network by repeatedly finding augmenting paths. BFS is used here to find paths (Edmonds-Karp variation). It works for graphs with integer capacities."
}
