{
"title": "Hopcroft-Karp Algorithm",
"subtitle": "Find maximum matching in a bipartite graph",
"time_complexity": "O(sqrt(V) * E)",
"space_complexity": "O(V + E)",
"category": "Graph / Matching",
"code": [
    "from collections import deque",
    "",
    "def bfs():",
    "    queue = deque()",
    "    for u in range(1, U+1):",
    "        if pair_u[u] == 0:",
    "            dist[u] = 0",
    "            queue.append(u)",
    "        else:",
    "            dist[u] = float('inf')",
    "    dist[0] = float('inf')",
    "    while queue:",
    "        u = queue.popleft()",
    "        if dist[u] < dist[0]:",
    "            for v in adj[u]:",
    "                if dist[pair_v[v]] == float('inf'):",
    "                    dist[pair_v[v]] = dist[u] + 1",
    "                    queue.append(pair_v[v])",
    "    return dist[0] != float('inf')",
    "",
    "def dfs(u):",
    "    if u != 0:",
    "        for v in adj[u]:",
    "            if dist[pair_v[v]] == dist[u] + 1 and dfs(pair_v[v]):",
    "                pair_v[v] = u",
    "                pair_u[u] = v",
    "                return True",
    "        dist[u] = float('inf')",
    "        return False",
    "    return True",
    "",
    "def hopcroft_karp():",
    "    matching = 0",
    "    while bfs():",
    "        for u in range(1, U+1):",
    "            if pair_u[u] == 0 and dfs(u):",
    "                matching += 1",
    "    return matching"
],
"additional_information": "Hopcroft-Karp efficiently finds maximum bipartite matchings by repeatedly finding maximal sets of shortest augmenting paths."
}
