{
"title": "Hungarian Algorithm",
"subtitle": "Solve the assignment problem / minimum cost bipartite matching",
"time_complexity": "O(N^3)",
"space_complexity": "O(N^2)",
"category": "Graph / Matching / Optimization",
"code": [
    "def hungarian(matrix):",
    "    # matrix: cost matrix",
    "    n = len(matrix)",
    "    u = [0] * n",
    "    v = [0] * n",
    "    p = [-1] * n",
    "    way = [-1] * n",
    "    for i in range(n):",
    "        minv = [float('inf')] * n",
    "        used = [False] * n",
    "        j0 = 0",
    "        p[0] = i",
    "        while True:",
    "            used[j0] = True",
    "            i0 = p[j0]",
    "            delta = float('inf')",
    "            j1 = -1",
    "            for j in range(1, n):",
    "                if not used[j]:",
    "                    cur = matrix[i0][j] - u[i0] - v[j]",
    "                    if cur < minv[j]:",
    "                        minv[j] = cur",
    "                        way[j] = j0",
    "                    if minv[j] < delta:",
    "                        delta = minv[j]",
    "                        j1 = j",
    "            for j in range(n):",
    "                if used[j]:",
    "                    u[p[j]] += delta",
    "                    v[j] -= delta",
    "                else:",
    "                    minv[j] -= delta",
    "            j0 = j1",
    "            if p[j0] == -1:",
    "                break",
    "        while j0 != 0:",
    "            j1 = way[j0]",
    "            p[j0] = p[j1]",
    "            j0 = j1",
    "    # Matching result can be extracted from p",
    "    return -v[0]"
],
"additional_information": "The Hungarian algorithm finds the minimum cost matching in a bipartite graph efficiently using potentials and augmenting paths."
}
